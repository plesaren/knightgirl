
<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>‡πÄ‡∏Å‡∏°‡∏•‡∏≤‡∏Å‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏†‡∏≤‡∏û</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%;
      font-family: sans-serif; background: #f0f0f0;
    }
    h1 { margin: 20px 0 10px; text-align: center; }
    p { text-align: center; margin-bottom: 10px; }
    #game-container {
      width: 90vw; height: 70vh; max-width: 1000px; max-height: 700px;
      border: 2px dashed #aaa; margin: 0 auto; position: relative;
      background: white; overflow: hidden; touch-action: none;
    }
    .piece {
      position: absolute; cursor: grab; user-select: none;
      touch-action: none; max-width: 100%; height: auto;
      transform-origin: center center;
    }
    .piece:active { cursor: grabbing; }
    .controls {
      text-align: center; margin-bottom: 10px;
    }
    .controls button {
      padding: 8px 16px; margin: 5px; font-size: 16px;
    }
  </style>
</head>
<body>

<h1>üß© ‡πÄ‡∏Å‡∏°‡∏•‡∏≤‡∏Å‡∏ä‡∏¥‡πâ‡∏ô‡∏™‡πà‡∏ß‡∏ô - ‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏•‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡∏î‡πâ‡∏≤‡∏ô</h1>
<p>‡πÅ‡∏ï‡∏∞‡∏†‡∏≤‡∏û‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ä‡πâ‡∏ô‡∏¥‡πâ‡∏ß‡∏´‡∏°‡∏∏‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏õ‡∏∏‡πà‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á</p>

<div class="controls">
  <button onclick="flipHorizontally()">‚ÜîÔ∏è ‡∏Å‡∏•‡∏±‡∏ö‡∏ã‡πâ‡∏≤‡∏¢‚Äì‡∏Ç‡∏ß‡∏≤</button>
  <button onclick="flipVertically()">‚ÜïÔ∏è ‡∏Å‡∏•‡∏±‡∏ö‡∏ö‡∏ô‚Äì‡∏•‡πà‡∏≤‡∏á</button>
  <button onclick="rotateLeft()">‚ü≤ ‡∏´‡∏°‡∏∏‡∏ô‡∏ã‡πâ‡∏≤‡∏¢</button>
  <button onclick="rotateRight()">‚ü≥ ‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏ß‡∏≤</button>
</div>

<div id="game-container"></div>

<script>
  const images = [
    "1-yellow-big-triangle.png",
    "2-red-big-triangle.png",
    "3-purple-medium-triangle.png",
    "4-blue-small-triangle.png",
    "5-pink-small-triangle.png",
    "6-orange-parallelogram.png",
    "7-green-diamond.png"
  ];

  const container = document.getElementById('game-container');
  let selectedPiece = null;

  images.forEach((src) => {
    const img = document.createElement('img');
    img.src = src;
    img.className = 'piece';
    img.dataset.flipX = "1";
    img.dataset.flipY = "1";
    img.dataset.rotate = "0";

    img.onload = () => {
      const maxX = container.clientWidth - img.width;
      const maxY = container.clientHeight - img.height;
      img.style.left = Math.random() * maxX + 'px';
      img.style.top = Math.random() * maxY + 'px';
    };

    img.onclick = () => selectedPiece = img;
    makeDraggableAndRotatable(img);
    container.appendChild(img);
  });

  function makeDraggableAndRotatable(el) {
    let offsetX = 0, offsetY = 0;
    let isDragging = false;
    let initialAngle = 0;
    let startAngle = 0;

    el.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        isDragging = true;
        const rect = el.getBoundingClientRect();
        offsetX = e.touches[0].clientX - rect.left;
        offsetY = e.touches[0].clientY - rect.top;
      } else if (e.touches.length === 2) {
        isDragging = false;
        const [t1, t2] = e.touches;
        initialAngle = getAngle(t1, t2);
        startAngle = parseFloat(el.dataset.rotate || "0");
      }
      selectedPiece = el;
    });

    el.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (isDragging && e.touches.length === 1) {
        const clientX = e.touches[0].clientX;
        const clientY = e.touches[0].clientY;
        const x = clientX - container.getBoundingClientRect().left - offsetX;
        const y = clientY - container.getBoundingClientRect().top - offsetY;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
      } else if (e.touches.length === 2) {
        const [t1, t2] = e.touches;
        const currentAngle = getAngle(t1, t2);
        const angleDiff = currentAngle - initialAngle;
        const newAngle = startAngle + angleDiff;
        el.dataset.rotate = newAngle;
        updateTransform(el);
      }
    });

    el.addEventListener('touchend', function() {
      isDragging = false;
    });

    el.onmousedown = function(e) {
      e.preventDefault();
      offsetX = e.offsetX;
      offsetY = e.offsetY;
      selectedPiece = el;

      document.onmousemove = function(e) {
        const x = e.clientX - container.getBoundingClientRect().left - offsetX;
        const y = e.clientY - container.getBoundingClientRect().top - offsetY;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
      };

      document.onmouseup = function() {
        document.onmousemove = null;
        document.onmouseup = null;
      };
    };

    el.addEventListener('wheel', function(e) {
      e.preventDefault();
      let currentAngle = parseFloat(el.dataset.rotate || "0");
      currentAngle += e.deltaY > 0 ? 5 : -5;
      el.dataset.rotate = currentAngle;
      updateTransform(el);
    });
  }

  function getAngle(t1, t2) {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  function flipHorizontally() {
    if (!selectedPiece) return;
    selectedPiece.dataset.flipX *= -1;
    updateTransform(selectedPiece);
  }

  function flipVertically() {
    if (!selectedPiece) return;
    selectedPiece.dataset.flipY *= -1;
    updateTransform(selectedPiece);
  }

  function rotateLeft() {
    if (!selectedPiece) return;
    let angle = parseFloat(selectedPiece.dataset.rotate || "0");
    angle -= 15;
    selectedPiece.dataset.rotate = angle;
    updateTransform(selectedPiece);
  }

  function rotateRight() {
    if (!selectedPiece) return;
    let angle = parseFloat(selectedPiece.dataset.rotate || "0");
    angle += 15;
    selectedPiece.dataset.rotate = angle;
    updateTransform(selectedPiece);
  }

  function updateTransform(img) {
    const scaleX = img.dataset.flipX || 1;
    const scaleY = img.dataset.flipY || 1;
    const rotate = img.dataset.rotate || 0;
    img.style.transform = `scale(${scaleX}, ${scaleY}) rotate(${rotate}deg)`;
  }
</script>

</body>
</html>
